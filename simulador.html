<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador Comparativo de Escalonadores</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .gantt-wrapper {
            position: relative;
            padding-top: 20px; /* Espaço para os marcadores de chegada */
            margin-bottom: 1rem; /* Espaço abaixo da régua */
        }
        .gantt-chart-container {
            display: flex;
            width: 100%;
            height: 40px;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            overflow: hidden;
            background-color: #f8fafc;
        }
        .gantt-bar {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.875rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            /* transition: width 0.3s ease-in-out; */ /* Removido para performance tick-by-tick */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-right: 1px solid rgba(0,0,0,0.1);
        }
        .gantt-bar:last-child {
            border-right: none;
        }
        .gantt-bar.idle {
            background-color: #f1f5f9;
            color: #64748b;
        }
        .table-cell {
            padding: 0.75rem;
            text-align: center;
            border-bottom: 1px solid #e2e8f0;
        }
        .timeline-container {
            position: relative;
            height: 20px;
            width: 100%;
            margin-top: 4px;
        }
        .timeline-tick {
            position: absolute;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 10px;
            color: #64748b;
        }
        .timeline-tick::before {
            content: '';
            width: 1px;
            height: 5px;
            background-color: #cbd5e1;
            display: block;
        }
        .arrival-marker-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 15px;
        }
        .arrival-marker {
            position: absolute;
            bottom: 0;
            transform: translateX(-50%);
            width: 1px;
            height: 100%;
            background-color: currentColor;
        }
        .arrival-marker::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 5px solid currentColor;
        }
        /* Estilo para destacar a melhor métrica na tabela de comparação */
        .best-metric {
             background-color: #d1fae5; /* Verde claro */
             font-weight: bold;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-screen-xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Simulador Comparativo de Escalonadores</h1>
            <p class="text-md text-gray-600 mt-2">FCFS | SJN | SRTF | Round Robin | MLFQ (macOS)</p>
        </header>

        <div class="flex flex-col gap-8">
            <!-- Seção de Configuração e Processos -->
            <div class="bg-white p-6 rounded-xl shadow-md">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Configurações e Processos</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <!-- Coluna de Configurações -->
                    <div>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                             <div>
                                <label for="quantumRR" class="block text-sm font-medium text-gray-700">Quantum (Round Robin)</label>
                                <input type="number" id="quantumRR" value="4" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                            </div>
                            
                            <div>
                                <label for="quantum1" class="block text-sm font-medium text-gray-700">Quantum Fila 1 (MLFQ)</label>
                                <input type="number" id="quantum1" value="8" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                            </div>
                            <div>
                                <label for="quantum2" class="block text-sm font-medium text-gray-700">Quantum Fila 2 (MLFQ)</label>
                                <input type="number" id="quantum2" value="16" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                            </div>
                             <div>
                                <label for="agingTime" class="block text-sm font-medium text-gray-700">Tempo de Boost (MLFQ)</label>
                                <input type="number" id="agingTime" value="40" min="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" title="Tempo que um processo pode esperar em uma fila baixa antes de ser promovido no MLFQ (0 para desativar).">
                            </div>
                        </div>
                         <button id="run-simulation" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105">
                            Executar Simulações
                        </button>
                    </div>
                    <!-- Coluna de Processos -->
                    <div>
                        <label for="processes" class="block text-sm font-medium text-gray-700">
                            Processos (ID, Chegada, Burst, Prioridade [MLFQ])
                        </label>
                        <textarea id="processes" rows="8" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 font-mono" placeholder="Exemplo:&#10;P1,0,10,1&#10;P2,2,5,1&#10;P3,4,20,2&#10;P4,5,8,3">P1,0,25,1
P2,2,10,1
P3,5,8,2
P4,30,6,1
P5,1,4,3</textarea>
                         <p class="mt-2 text-xs text-gray-500">A Prioridade (1, 2 ou 3) é usada apenas no algoritmo MLFQ.</p>
                    </div>
                </div>
            </div>

            <!-- Seção de Resultados -->
            <div id="results-container" class="bg-white p-6 rounded-xl shadow-md hidden">
                 <!-- Os resultados de cada algoritmo serão inseridos aqui -->
                 <div id="fcfs-results"></div>
                 <div id="sjn-results"></div>
                 <div id="srtf-results"></div>
                 <div id="rr-results"></div>
                 <div id="mlfq-results"></div>

                 <!-- Tabela de Comparação Final -->
                 <div id="comparison-results" class="mt-10">
                     <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Comparação das Métricas Médias</h2>
                      <div class="overflow-x-auto mt-2 rounded-lg border">
                            <table class="min-w-full divide-y divide-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="table-cell font-semibold">Algoritmo</th>
                                        <th class="table-cell font-semibold">TMT</th>
                                        <th class="table-cell font-semibold">TME</th>
                                    </tr>
                                </thead>
                                <tbody id="comparison-table-body" class="bg-white divide-y divide-gray-200">
                                    <!-- Os resultados da comparação serão inseridos aqui -->
                                </tbody>
                            </table>
                        </div>
                         <p class="mt-4 text-sm text-gray-600 text-center">Valores menores são melhores. A célula destacada indica o melhor resultado para cada métrica.</p>
                 </div>
            </div>
        </div>
    </div>

    <script>
        // --- FUNÇÕES AUXILIARES ---

        /**
         * Adiciona um bloco de execução a um array de histórico do Gantt.
         * Se o último bloco for do mesmo processo/estado, mescla os blocos.
         */
        function addGanttBlock(ganttArray, id, duration) {
            // Não adiciona blocos de duração zero ou negativa
            if (duration <= 0) return;
            // Se o último bloco é o mesmo, incrementa a duração
            if (ganttArray.length > 0 && ganttArray[ganttArray.length - 1].id === id) {
                ganttArray[ganttArray.length - 1].duration += duration;
            } else {
                // Senão, adiciona um novo bloco
                ganttArray.push({ id: id, duration: duration });
            }
        }

        /**
         * Cria uma cópia profunda de um array de objetos de processo.
         * Necessário para que cada simulação não modifique os dados das outras.
         */
        function deepCopyProcesses(processes) {
            return JSON.parse(JSON.stringify(processes));
        }

        // --- LÓGICA DE SIMULAÇÃO DOS ALGORITMOS ---

        /**
         * Simula o algoritmo First-Come, First-Served (FCFS).
         * @param {Array} processesCopy - Uma cópia da lista de processos.
         * @returns {object} - Contém o ganttData e o processMap com métricas.
         */
        function simulateFCFS(processesCopy) {
            const ganttData = [];
            const processMap = new Map(processesCopy.map(p => [p.id, p]));
            let currentTime = 0;
            let readyQueue = [];
            let processIndex = 0;
            let completedProcesses = 0;

            // Ordena por chegada (já deve estar, mas garante).
            processesCopy.sort((a, b) => a.arrivalTime - b.arrivalTime);

            while (completedProcesses < processesCopy.length) {
                // Adiciona processos que chegaram à fila de prontos.
                while (processIndex < processesCopy.length && processesCopy[processIndex].arrivalTime <= currentTime) {
                    readyQueue.push(processesCopy[processIndex]);
                    processIndex++;
                }

                if (readyQueue.length > 0) {
                    // Pega o primeiro processo que chegou (FCFS).
                    const currentProcess = readyQueue.shift();
                    const executionTime = currentProcess.burstTime; // Executa o burst inteiro (não preemptivo).

                    // Garante que o processo não execute antes de chegar (caso haja ociosidade)
                    if (currentProcess.arrivalTime > currentTime) {
                         const idleTime = currentProcess.arrivalTime - currentTime;
                         addGanttBlock(ganttData, 'Ocioso', idleTime);
                         currentTime = currentProcess.arrivalTime;
                    }

                    addGanttBlock(ganttData, currentProcess.id, executionTime);
                    currentTime += executionTime;

                    // Calcula métricas.
                    currentProcess.completionTime = currentTime;
                    currentProcess.turnaroundTime = currentProcess.completionTime - currentProcess.arrivalTime;
                    currentProcess.waitingTime = currentProcess.turnaroundTime - currentProcess.burstTime;
                    completedProcesses++;
                } else if (processIndex < processesCopy.length) {
                    // Se a fila está vazia mas ainda há processos por chegar, avança o tempo até a próxima chegada.
                    const idleTime = processesCopy[processIndex].arrivalTime - currentTime;
                    addGanttBlock(ganttData, 'Ocioso', idleTime);
                    currentTime = processesCopy[processIndex].arrivalTime;
                } else {
                     break; // Fim da simulação
                }
            }
            return { ganttData, processMap };
        }

        /**
         * Simula o algoritmo Shortest Job Next (SJN - Não Preemptivo).
         */
         function simulateSJN(processesCopy) {
            const ganttData = [];
            const processMap = new Map(processesCopy.map(p => [p.id, p]));
            let currentTime = 0;
            let readyQueue = [];
            let processIndex = 0;
            let completedProcesses = 0;

            processesCopy.sort((a, b) => a.arrivalTime - b.arrivalTime);

            while (completedProcesses < processesCopy.length) {
                 while (processIndex < processesCopy.length && processesCopy[processIndex].arrivalTime <= currentTime) {
                    readyQueue.push(processesCopy[processIndex]);
                    processIndex++;
                }

                if (readyQueue.length > 0) {
                     // Ordena a fila de prontos pelo menor burst time TOTAL a cada decisão.
                     readyQueue.sort((a, b) => a.burstTime - b.burstTime);

                    // Pega o processo com o menor burst time.
                    const currentProcess = readyQueue.shift();
                    const executionTime = currentProcess.burstTime; // Não preemptivo.

                     // Garante que o processo não execute antes de chegar (caso haja ociosidade)
                    if (currentProcess.arrivalTime > currentTime) {
                         const idleTime = currentProcess.arrivalTime - currentTime;
                         addGanttBlock(ganttData, 'Ocioso', idleTime);
                         currentTime = currentProcess.arrivalTime;
                    }

                    addGanttBlock(ganttData, currentProcess.id, executionTime);
                    currentTime += executionTime;

                    currentProcess.completionTime = currentTime;
                    currentProcess.turnaroundTime = currentProcess.completionTime - currentProcess.arrivalTime;
                    currentProcess.waitingTime = currentProcess.turnaroundTime - currentProcess.burstTime;
                    completedProcesses++;
                } else if (processIndex < processesCopy.length) {
                    const idleTime = processesCopy[processIndex].arrivalTime - currentTime;
                    addGanttBlock(ganttData, 'Ocioso', idleTime);
                    currentTime = processesCopy[processIndex].arrivalTime;
                } else {
                    break;
                }
            }
            return { ganttData, processMap };
        }

        /**
         * Simula o algoritmo Shortest Remaining Time First (SRTF - Preemptivo).
         * Lógica tick-by-tick para preempção correta.
         */
        function simulateSRTF(processesCopy) {
            const ganttData = [];
            const processMap = new Map(processesCopy.map(p => [p.id, p]));
            let currentTime = 0;
            let readyQueue = [];
            let processIndex = 0;
            let completedProcesses = 0;
            let currentProcess = null; // Processo atualmente na CPU

            processesCopy.sort((a, b) => a.arrivalTime - b.arrivalTime);
            processesCopy.forEach(p => p.remainingTime = p.burstTime); // Inicializa tempo restante

            while (completedProcesses < processesCopy.length) {
                // Adiciona processos que chegaram neste exato tick de tempo
                while (processIndex < processesCopy.length && processesCopy[processIndex].arrivalTime === currentTime) {
                    readyQueue.push(processesCopy[processIndex]);
                    processIndex++;
                }

                // Se houver processos na fila de prontos, ordena pelo tempo restante
                if (readyQueue.length > 0) {
                    readyQueue.sort((a, b) => a.remainingTime - b.remainingTime);
                    const shortestReady = readyQueue[0];

                    // Verifica se o processo atual deve ser preemptado
                    if (currentProcess && currentProcess.remainingTime > 0 && shortestReady.remainingTime < currentProcess.remainingTime) {
                        // Preempção: Coloca o processo atual de volta na fila
                        readyQueue.push(currentProcess);
                        currentProcess = null; // Força a reescolha
                        // Reordena após adicionar o preemptado
                        readyQueue.sort((a, b) => a.remainingTime - b.remainingTime);
                    }
                }

                // Se a CPU está livre e há processos prontos, escolhe o mais curto
                if (!currentProcess && readyQueue.length > 0) {
                    currentProcess = readyQueue.shift();
                }

                // Executa 1 tick do processo atual ou marca como ocioso
                if (currentProcess) {
                    addGanttBlock(ganttData, currentProcess.id, 1);
                    currentProcess.remainingTime--;

                    // Verifica se o processo terminou
                    if (currentProcess.remainingTime <= 0) {
                        currentProcess.completionTime = currentTime + 1; // Termina no *fim* deste tick
                        currentProcess.turnaroundTime = currentProcess.completionTime - currentProcess.arrivalTime;
                        currentProcess.waitingTime = currentProcess.turnaroundTime - currentProcess.burstTime;
                        completedProcesses++;
                        currentProcess = null; // Libera a CPU
                    }
                } else {
                     // Fica ocioso apenas se houver processos futuros ou na fila (evita ociosidade infinita no final)
                     if (processIndex < processesCopy.length || readyQueue.length > 0) {
                         addGanttBlock(ganttData, 'Ocioso', 1);
                     } else if (completedProcesses < processesCopy.length) {
                        // Situação de erro ou espera por processo que ainda não chegou mas deveria
                        // Adiciona ocioso para avançar o tempo até a próxima chegada teórica
                         if (processIndex < processesCopy.length) {
                              const nextArrivalTime = processesCopy[processIndex].arrivalTime;
                              const idleTime = nextArrivalTime - currentTime;
                              addGanttBlock(ganttData, 'Ocioso', idleTime);
                              currentTime = nextArrivalTime -1; // Ajusta para o loop incrementar para o tempo certo
                         } else {
                             // Não deveria chegar aqui se a lógica estiver correta
                             break;
                         }
                     }
                }

                currentTime++; // Avança o relógio global

                // Limite de segurança
                if (currentTime > 50000 && completedProcesses < processesCopy.length) {
                    console.error("SRTF: Simulação excedeu limite de tempo. Verificando loop infinito.");
                    break;
                }
            }
             // Consolida métricas finais no processMap original
             processesCopy.forEach(p => {
                const mapEntry = processMap.get(p.id);
                if (mapEntry) {
                    mapEntry.completionTime = p.completionTime;
                    mapEntry.turnaroundTime = p.turnaroundTime;
                    mapEntry.waitingTime = p.waitingTime;
                }
             });
             return { ganttData, processMap };
        }


       /**
         * Simula o algoritmo Round Robin (RR - Preemptivo).
         */
        function simulateRR(processesCopy, quantum) {
            const ganttData = [];
            const processMap = new Map(processesCopy.map(p => [p.id, p]));
            let currentTime = 0;
            let readyQueue = [];
            let processIndex = 0;
            let completedProcesses = 0;

            processesCopy.sort((a, b) => a.arrivalTime - b.arrivalTime);
            processesCopy.forEach(p => p.remainingTime = p.burstTime);

            while (completedProcesses < processesCopy.length) {
                 // Adiciona processos que chegaram ATÉ o tempo atual
                 while (processIndex < processesCopy.length && processesCopy[processIndex].arrivalTime <= currentTime) {
                    readyQueue.push(processesCopy[processIndex]);
                    processIndex++;
                }

                if (readyQueue.length > 0) {
                    const currentProcess = readyQueue.shift(); // Pega o próximo da fila circular.
                    const executionTime = Math.min(currentProcess.remainingTime, quantum);

                    addGanttBlock(ganttData, currentProcess.id, executionTime);
                    currentTime += executionTime;
                    currentProcess.remainingTime -= executionTime;

                    // Adiciona novos processos que chegaram *durante* a execução deste quantum.
                     while (processIndex < processesCopy.length && processesCopy[processIndex].arrivalTime <= currentTime) {
                        readyQueue.push(processesCopy[processIndex]);
                        processIndex++;
                    }

                    if (currentProcess.remainingTime <= 0) {
                        // Processo concluído.
                        currentProcess.completionTime = currentTime;
                        currentProcess.turnaroundTime = currentProcess.completionTime - currentProcess.arrivalTime;
                        currentProcess.waitingTime = currentProcess.turnaroundTime - currentProcess.burstTime;
                        completedProcesses++;
                    } else {
                        // Processo não terminou, volta para o fim da fila.
                        readyQueue.push(currentProcess);
                    }
                } else if (processIndex < processesCopy.length) {
                     // Fila vazia, avança para a próxima chegada.
                    const idleTime = processesCopy[processIndex].arrivalTime - currentTime;
                    addGanttBlock(ganttData, 'Ocioso', idleTime);
                    currentTime = processesCopy[processIndex].arrivalTime;
                } else {
                    break; // Fila vazia e sem mais processos para chegar.
                }
            }
            return { ganttData, processMap };
        }


        /**
         * Simula o algoritmo Multi-Level Feedback Queue (MLFQ).
         * Implementação tick-by-tick para preempção correta por prioridade.
         */
        function simulateMLFQ(processesCopy, quantum1, quantum2, agingTime) {
            const gantt = { geral: [], q1: [], q2: [], q3: [] }; // Históricos de Gantt
            const processMap = new Map(processesCopy.map(p => [p.id, p])); // Para métricas finais
            let currentTime = 0;
            let completedProcesses = 0;
            const queues = [[], [], []]; // Filas de prontos (índice 0 = Prio 1, índice 2 = Prio 3)
            let processIndex = 0; // Para percorrer a lista de processos que chegam
            let currentProcess = null; // Processo atualmente na CPU
            let currentQueueIndex = -1; // Índice da fila do processo atual
            let currentQuantumRemaining = 0; // Tempo restante no quantum atual (para RR nas filas 1 e 2)

            processesCopy.sort((a, b) => a.arrivalTime - b.arrivalTime);
            processesCopy.forEach(p => {
                p.remainingTime = p.burstTime;
                p.initialPriorityIndex = Math.max(0, Math.min(2, p.priority - 1)); // Índice da fila inicial
                p.currentPriorityIndex = p.initialPriorityIndex; // Prioridade atual (pode mudar)
                p.lastReadyTime = p.arrivalTime; // Para cálculo de aging (tempo desde que ficou pronto)
            });

            while (completedProcesses < processesCopy.length) {

                // **PASSO A: CHEGADA DE PROCESSOS**
                while (processIndex < processesCopy.length && processesCopy[processIndex].arrivalTime === currentTime) {
                    const arrivingProcess = processesCopy[processIndex];
                    arrivingProcess.currentPriorityIndex = arrivingProcess.initialPriorityIndex; // Reseta prioridade na chegada
                    arrivingProcess.lastReadyTime = currentTime; // Marca quando entrou na fila
                    queues[arrivingProcess.currentPriorityIndex].push(arrivingProcess);
                    processIndex++;
                }

                // **PASSO B: PROMOÇÃO POR AGING**
                if (agingTime > 0) {
                    // Verifica das filas inferiores (2 e 1) para cima
                    for (let i = 2; i > 0; i--) {
                        const processesToPromote = [];
                        // Filtra processos que esperaram o suficiente *e não estão rodando*
                        queues[i] = queues[i].filter(p => {
                            if ((currentTime - p.lastReadyTime) >= agingTime && p !== currentProcess) {
                                processesToPromote.push(p);
                                return false; // Remove da fila atual
                            }
                            return true; // Mantém na fila atual
                        });
                        // Adiciona promovidos à fila superior
                        processesToPromote.forEach(p => {
                            p.currentPriorityIndex = i - 1; // Atualiza prioridade
                            p.lastReadyTime = currentTime; // Reseta tempo de espera na nova fila
                            queues[i - 1].push(p);
                        });
                    }
                }

                // **PASSO C: SELEÇÃO E PREEMPÇÃO**
                let highestPriorityProcess = null;
                let highestPriorityQueueIndex = -1;
                // Encontra o processo de maior prioridade pronto
                for (let i = 0; i < 3; i++) {
                    if (queues[i].length > 0) {
                        highestPriorityProcess = queues[i][0]; // Apenas olha, não remove ainda
                        highestPriorityQueueIndex = i;
                        break;
                    }
                }

                // Verifica se deve ocorrer preempção
                if (currentProcess && highestPriorityProcess && highestPriorityQueueIndex < currentQueueIndex) {
                    // Sim, processo pronto tem prioridade maior que o atual!
                    // Coloca o processo atual de volta na sua fila
                    queues[currentQueueIndex].unshift(currentProcess); // Coloca no início da fila
                    currentProcess.lastReadyTime = currentTime; // Marca que voltou pra fila agora
                    currentProcess = null; // Libera a CPU
                    currentQueueIndex = -1;
                    currentQuantumRemaining = 0;
                }

                // Se a CPU está ociosa, pega o processo de maior prioridade
                if (!currentProcess && highestPriorityProcess) {
                    currentProcess = queues[highestPriorityQueueIndex].shift(); // Agora sim remove da fila
                    currentQueueIndex = highestPriorityQueueIndex;
                    // Define o quantum para as filas RR
                    if (currentQueueIndex === 0) currentQuantumRemaining = quantum1;
                    else if (currentQueueIndex === 1) currentQuantumRemaining = quantum2;
                    else currentQuantumRemaining = currentProcess.remainingTime; // Fila FCFS
                }

                // **PASSO D: EXECUÇÃO OU OCIOSIDADE**
                if (currentProcess) {
                    // Registra a execução no Gantt
                    addGanttBlock(gantt.geral, currentProcess.id, 1);
                    const ganttQueues = [gantt.q1, gantt.q2, gantt.q3];
                    addGanttBlock(ganttQueues[currentQueueIndex], currentProcess.id, 1);
                    // Registra ociosidade nas outras filas
                    for (let i = 0; i < 3; i++) {
                        if (i !== currentQueueIndex) {
                            addGanttBlock(ganttQueues[i], 'Ocioso', 1);
                        }
                    }

                    // Atualiza tempos
                    currentProcess.remainingTime--;
                    currentQuantumRemaining--;

                    // **PASSO E: VERIFICA TÉRMINO OU FIM DO QUANTUM/REBAIXAMENTO**
                    if (currentProcess.remainingTime <= 0) {
                        // Processo terminou
                        completedProcesses++;
                        const stats = processMap.get(currentProcess.id);
                        stats.completionTime = currentTime + 1; // Termina no fim deste tick
                        stats.turnaroundTime = stats.completionTime - stats.arrivalTime;
                        stats.waitingTime = stats.turnaroundTime - stats.burstTime;
                        currentProcess = null; // Libera CPU
                        currentQueueIndex = -1;
                        currentQuantumRemaining = 0;
                    } else if (currentQuantumRemaining <= 0 && currentQueueIndex < 2) {
                        // Quantum expirou (e não está na última fila) -> Rebaixar
                        const nextQueueIndex = currentQueueIndex + 1;
                        currentProcess.currentPriorityIndex = nextQueueIndex;
                        currentProcess.lastReadyTime = currentTime + 1; // Entrará na fila no próximo tick
                        queues[nextQueueIndex].push(currentProcess); // Adiciona na fila inferior
                        currentProcess = null; // Libera CPU
                        currentQueueIndex = -1;
                        currentQuantumRemaining = 0;
                    }
                     // Se não terminou nem expirou quantum (ou está na Fila 3), continua rodando no próximo tick

                } else {
                    // Ninguém para rodar -> Ocioso
                    addGanttBlock(gantt.geral, 'Ocioso', 1);
                    addGanttBlock(gantt.q1, 'Ocioso', 1);
                    addGanttBlock(gantt.q2, 'Ocioso', 1);
                    addGanttBlock(gantt.q3, 'Ocioso', 1);
                }

                 // Atualiza o tempo de espera para processos que não rodaram
                 queues.forEach((queue, index) => {
                    queue.forEach(p => {
                        if (p !== currentProcess) {
                             // Se o lastReadyTime não foi atualizado neste tick, significa que ele está esperando
                             // (Incrementamos o tempo de espera implicitamente pelo currentTime)
                             // Mas precisamos ter certeza que lastReadyTime reflete quando ele ficou pronto *nesta fila*
                             // A lógica de aging já usa isso.
                        }
                    });
                 });


                currentTime++; // Avança o relógio global

                // Condição de saída de segurança
                 if (currentTime > 50000 && completedProcesses < processesCopy.length) {
                    console.error("MLFQ: Simulação excedeu limite de tempo.");
                    break;
                }
            } // Fim do while principal

             // Consolida métricas finais
             processesCopy.forEach(p => {
                 const mapEntry = processMap.get(p.id);
                 if (mapEntry) {
                     mapEntry.completionTime = p.completionTime || currentTime; // Se não completou por erro, usa o tempo final
                     mapEntry.turnaroundTime = mapEntry.completionTime - p.arrivalTime;
                     mapEntry.waitingTime = mapEntry.turnaroundTime - p.burstTime;
                 }
             });

            return { gantt, processMap };
        }


        // --- FUNÇÃO PRINCIPAL DISPARADA PELO BOTÃO ---

        document.getElementById('run-simulation').addEventListener('click', () => {
            // --- 1. OBTER CONFIGURAÇÕES E PROCESSOS ---
            const quantumRR = parseInt(document.getElementById('quantumRR').value);
            const quantum1 = parseInt(document.getElementById('quantum1').value);
            const quantum2 = parseInt(document.getElementById('quantum2').value);
            const agingTime = parseInt(document.getElementById('agingTime').value);
            const processesInput = document.getElementById('processes').value.trim().split('\n');
            
             // Validações
            if (isNaN(quantumRR) || quantumRR <= 0 || isNaN(quantum1) || isNaN(quantum2) || quantum1 <= 0 || quantum2 <= 0 || isNaN(agingTime) || agingTime < 0) {
                alert("Valores de Quantum/Aging inválidos.");
                return;
            }

             // Parse dos processos (com prioridade para MLFQ)
            const originalProcesses = processesInput.map(line => {
                const parts = line.split(',');
                if (parts.length !== 4) return null;
                const priority = parseInt(parts[3]);
                return {
                    id: parts[0].trim(), arrivalTime: parseInt(parts[1]), burstTime: parseInt(parts[2]),
                    // Guarda a prioridade original e inicializa outras props
                    priority: Math.max(1, Math.min(3, priority)),
                    // remainingTime e outras serão definidas dentro de cada simulação
                    completionTime: 0, waitingTime: 0, turnaroundTime: 0
                };
            }).filter(p => p && !isNaN(p.arrivalTime) && !isNaN(p.burstTime) && p.burstTime > 0);

            if (originalProcesses.length === 0) {
                alert("Nenhum processo válido encontrado. Formato: ID,Chegada,Burst,Prioridade");
                return;
            }
             // Ordena por chegada para garantir consistência inicial
            originalProcesses.sort((a, b) => a.arrivalTime - b.arrivalTime);

            // --- 2. EXECUTAR TODAS AS SIMULAÇÕES ---
            // É crucial usar deepCopyProcesses para cada simulação!
            const results = {};
            try {
                results.fcfs = simulateFCFS(deepCopyProcesses(originalProcesses));
                results.sjn = simulateSJN(deepCopyProcesses(originalProcesses));
                results.srtf = simulateSRTF(deepCopyProcesses(originalProcesses));
                results.rr = simulateRR(deepCopyProcesses(originalProcesses), quantumRR);
                results.mlfq = simulateMLFQ(deepCopyProcesses(originalProcesses), quantum1, quantum2, agingTime);
            } catch (error) {
                console.error("Erro durante a simulação:", error);
                alert("Ocorreu um erro durante a simulação. Verifique o console para detalhes.");
                return;
            }

            // --- 3. RENDERIZAR TODOS OS RESULTADOS ---
            renderAllResults(results, originalProcesses);
        });

        // --- FUNÇÕES DE RENDERIZAÇÃO GERAL ---

        const colorPalette = ['#3498db', '#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];
        const processColors = {};
        let colorIndex = 0;

        // Atribui uma cor única e consistente para cada ID de processo.
        function getProcessColor(processId) {
            if (processId === 'Ocioso') return '#f1f5f9'; // Cor específica para ocioso
            if (!processColors[processId]) {
                processColors[processId] = colorPalette[colorIndex % colorPalette.length];
                colorIndex++;
            }
            return processColors[processId];
        }

        /**
         * Renderiza um único gráfico de Gantt e sua régua. Adaptada para os diferentes formatos de ganttData.
         */
        function renderGantt(wrapperElement, ganttData, totalTime, originalProcesses, queueFilter = 0) {
            // Encontra os elementos dentro do wrapper fornecido.
            if (!wrapperElement) {
                console.error("Elemento wrapper do Gantt não encontrado para:", wrapperElement);
                return;
            }
            const ganttContainer = wrapperElement.querySelector('.gantt-chart-container');
            const timelineContainer = wrapperElement.querySelector('.timeline-container');
            const markerContainer = wrapperElement.querySelector('.arrival-marker-container');

             if (!ganttContainer || !timelineContainer || !markerContainer) {
                 console.error("Elementos internos do Gantt não encontrados no wrapper:", wrapperElement.id);
                 return;
             }
            
            // Limpa antes de redesenhar.
            ganttContainer.innerHTML = '';
            timelineContainer.innerHTML = '';
            markerContainer.innerHTML = '';

             // Desenha as barras
            (ganttData || []).forEach(item => {
                const bar = document.createElement('div');
                const width = totalTime > 0 ? (item.duration / totalTime) * 100 : 0;
                 if (width < 0.01) return; // Não renderiza barras minúsculas
                bar.style.width = `${width}%`;
                bar.className = 'gantt-bar';
                // Mostra ID apenas se a barra for larga o suficiente
                if (width > (item.id === 'Ocioso' ? 5 : 2.5)) { bar.textContent = item.id; }
                bar.title = `${item.id} (${item.duration}ms)`;
                bar.style.backgroundColor = getProcessColor(item.id);
                if (item.id === 'Ocioso') { bar.classList.add('idle'); }

                ganttContainer.appendChild(bar);
            });

             // Desenha a régua de tempo
            if (totalTime > 0) {
                const maxTicks = 30; // Alvo para o número de marcadores na régua
                const niceIntervals = [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]; // Intervalos "bonitos"
                let tickInterval = 1;

                // Encontra o menor intervalo "bonito" que não sobrecarrega a régua
                for (const interval of niceIntervals) {
                    if (totalTime / interval <= maxTicks) {
                        tickInterval = interval;
                        break;
                    }
                }
                // Se nenhum intervalo "bonito" servir (tempo total muito grande), calcula um.
                if (totalTime / tickInterval > maxTicks * 1.5) {
                    const magnitude = Math.pow(10, Math.floor(Math.log10(totalTime / maxTicks)));
                    tickInterval = Math.ceil(totalTime / maxTicks / magnitude) * magnitude;
                    if (tickInterval <= 0) tickInterval = 1; // Garante intervalo positivo
                }

                const ticks = new Set([0]); // Garante o tick 0
                for (let time = tickInterval; time < totalTime; time += tickInterval) {
                     // Arredonda para evitar números quebrados demais se tickInterval for < 1
                     ticks.add(tickInterval < 1 ? parseFloat(time.toFixed(1)) : Math.floor(time));
                }
                ticks.add(totalTime); // Garante o tick final

                ticks.forEach(time => {
                    const tick = document.createElement('div');
                    tick.className = 'timeline-tick';
                    const percentage = (time / totalTime) * 100;
                    tick.style.left = `min(calc(${percentage}% - 1px), calc(100% - 15px))`; // Evita que o último tick saia da tela
                    tick.innerHTML = `<span>${time}</span>`;
                    timelineContainer.appendChild(tick);
                });
            }

            // Desenha os marcadores de chegada (setas)
            originalProcesses.forEach(p => {
                 // Mostra no gráfico geral (queueFilter 0) ou na fila inicial do processo (para MLFQ)
                if (p.arrivalTime <= totalTime && (queueFilter === 0 || p.priority === queueFilter)) {
                    const marker = document.createElement('div');
                    marker.className = 'arrival-marker';
                    const percentage = totalTime > 0 ? (p.arrivalTime / totalTime) * 100 : 0;
                    marker.style.left = `${percentage}%`;
                    marker.style.color = getProcessColor(p.id); // Cor da seta = cor do processo
                    marker.title = `Chegada de ${p.id} em t=${p.arrivalTime}`;
                    markerContainer.appendChild(marker);
                }
            });
        }
        
        /**
         * Cria o HTML para a seção de resultados de UM algoritmo específico.
         */
         function createAlgorithmResultSection(algoName, algoTitle, resultData, originalProcesses) {
            const section = document.createElement('div');
            section.id = `${algoName}-results-section`;
            section.classList.add('mt-8', 'border-t', 'pt-8');

            // --- Estrutura HTML ---
             // Gantt Geral (todos os algoritmos têm)
            let ganttHtml = `
                <h3 class="text-xl font-semibold mb-3">${algoTitle}</h3>
                <div class="gantt-wrapper" id="gantt-${algoName}-geral-wrapper">
                     <div class="arrival-marker-container"></div>
                     <div class="gantt-chart-container"></div>
                     <div class="timeline-container"></div>
                </div>`;

             // Gantts específicos das filas para MLFQ
             if (algoName === 'mlfq') {
                 ganttHtml += `
                 <h4 class="text-lg font-medium mt-4">Gantt Fila 1 (RR)</h4>
                 <div class="gantt-wrapper" id="gantt-${algoName}-q1-wrapper">
                     <div class="arrival-marker-container"></div>
                     <div class="gantt-chart-container"></div>
                     <div class="timeline-container"></div>
                 </div>
                 <h4 class="text-lg font-medium mt-4">Gantt Fila 2 (RR)</h4>
                 <div class="gantt-wrapper" id="gantt-${algoName}-q2-wrapper">
                     <div class="arrival-marker-container"></div>
                     <div class="gantt-chart-container"></div>
                     <div class="timeline-container"></div>
                 </div>
                 <h4 class="text-lg font-medium mt-4">Gantt Fila 3 (FCFS)</h4>
                 <div class="gantt-wrapper" id="gantt-${algoName}-q3-wrapper">
                     <div class="arrival-marker-container"></div>
                     <div class="gantt-chart-container"></div>
                     <div class="timeline-container"></div>
                 </div>`;
             }

             // Tabela de Métricas Detalhadas
            let tableHtml = `
                <h4 class="text-lg font-medium mt-6">Métricas Detalhadas (${algoTitle})</h4>
                <div class="overflow-x-auto mt-2 rounded-lg border">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="table-cell font-semibold">ID</th>
                                <th class="table-cell font-semibold">Chegada</th>
                                <th class="table-cell font-semibold">Burst</th>
                                <th class="table-cell font-semibold">Conclusão</th>
                                <th class="table-cell font-semibold">Turnaround</th>
                                <th class="table-cell font-semibold">Espera</th>
                            </tr>
                        </thead>
                        <tbody id="table-${algoName}" class="bg-white divide-y divide-gray-200">`;

            // --- Cálculo das Médias e Preenchimento da Tabela ---
            let totalTurnaround = 0;
            let totalWaiting = 0;
            let processCount = 0;
            const sortedProcesses = Array.from(resultData.processMap.values()).sort((a,b) => {
                 const numA = parseInt(a.id.replace(/[^0-9]/g, ''), 10);
                 const numB = parseInt(b.id.replace(/[^0-9]/g, ''), 10);
                 if (isNaN(numA) || isNaN(numB)) return a.id.localeCompare(b.id);
                 return numA - numB;
            });

            sortedProcesses.forEach(p => {
                 // Garante que métricas negativas (possíveis por erros de arredondamento mínimo) sejam zeradas
                 p.turnaroundTime = Math.max(0, p.turnaroundTime);
                 p.waitingTime = Math.max(0, p.waitingTime);

                totalTurnaround += p.turnaroundTime;
                totalWaiting += p.waitingTime;
                processCount++;
                tableHtml += `<tr>
                    <td class="table-cell font-medium">${p.id}</td>
                    <td class="table-cell">${p.arrivalTime}</td>
                    <td class="table-cell">${p.burstTime}</td>
                    <td class="table-cell">${p.completionTime}</td>
                    <td class="table-cell">${p.turnaroundTime}</td>
                    <td class="table-cell">${p.waitingTime}</td>
                </tr>`;
            });

            tableHtml += `</tbody></table></div>`;

            // --- HTML das Métricas Médias ---
            const avgTurnaround = processCount > 0 ? totalTurnaround / processCount : 0;
            const avgWaiting = processCount > 0 ? totalWaiting / processCount : 0;
            const metricsHtml = `
                <div class="mt-4 text-center bg-gray-100 p-3 rounded-lg">
                    <h4 class="text-md font-medium">Métricas Médias (${algoTitle})</h4>
                    <div class="flex justify-center space-x-6 mt-1">
                         <p class="text-sm text-gray-700">TMT: <span class="font-bold">${avgTurnaround.toFixed(2)}</span></p>
                         <p class="text-sm text-gray-700">TME: <span class="font-bold">${avgWaiting.toFixed(2)}</span></p>
                    </div>
                </div>`;

            section.innerHTML = ganttHtml + tableHtml + metricsHtml;

            // Retorna a seção e as médias calculadas
             return { section, avgTurnaround, avgWaiting };
        }


        /**
         * Orquestra a renderização de todas as seções de resultado e a tabela de comparação.
         */
        function renderAllResults(allResults, originalProcesses) {
            document.getElementById('results-container').classList.remove('hidden'); // Mostra a área de resultados.
            
            // Limpa cores e resultados anteriores
            colorIndex = 0;
            Object.keys(processColors).forEach(key => delete processColors[key]);
            const resultKeys = ['fcfs', 'sjn', 'srtf', 'rr', 'mlfq'];
             resultKeys.forEach(key => {
                 const container = document.getElementById(`${key}-results`);
                 if (container) container.innerHTML = '';
             });
             document.getElementById('comparison-table-body').innerHTML = '';


            const comparisonData = []; // Para armazenar as médias de cada algoritmo

             // Define os títulos
             const titles = {
                 fcfs: 'FCFS (First-Come, First-Served)',
                 sjn: 'SJN (Shortest Job Next)',
                 srtf: 'SRTF (Shortest Remaining Time First)',
                 rr: 'Round Robin',
                 mlfq: 'MLFQ (Multi-Level Feedback Queue)'
             };

            // Itera sobre cada algoritmo para criar sua seção e obter métricas
             resultKeys.forEach(key => {
                 if (allResults[key]) {
                     const renderResult = createAlgorithmResultSection(key, titles[key], allResults[key], originalProcesses);
                     document.getElementById(`${key}-results`).appendChild(renderResult.section);
                     comparisonData.push({ name: titles[key], tmt: renderResult.avgTurnaround, tme: renderResult.avgWaiting });
                 } else {
                     console.warn(`Resultados para ${key} não encontrados.`);
                 }
             });

            // Chama renderGantt para cada gráfico após a estrutura HTML ser criada
            try {
                const totalTimeFCFS = allResults.fcfs?.ganttData?.reduce((sum, item) => sum + item.duration, 0) || 0;
                if (totalTimeFCFS > 0) renderGantt(document.getElementById('gantt-fcfs-geral-wrapper'), allResults.fcfs.ganttData, totalTimeFCFS, originalProcesses);

                const totalTimeSJN = allResults.sjn?.ganttData?.reduce((sum, item) => sum + item.duration, 0) || 0;
                if (totalTimeSJN > 0) renderGantt(document.getElementById('gantt-sjn-geral-wrapper'), allResults.sjn.ganttData, totalTimeSJN, originalProcesses);

                const totalTimeSRTF = allResults.srtf?.ganttData?.reduce((sum, item) => sum + item.duration, 0) || 0;
                if (totalTimeSRTF > 0) renderGantt(document.getElementById('gantt-srtf-geral-wrapper'), allResults.srtf.ganttData, totalTimeSRTF, originalProcesses);

                const totalTimeRR = allResults.rr?.ganttData?.reduce((sum, item) => sum + item.duration, 0) || 0;
                if (totalTimeRR > 0) renderGantt(document.getElementById('gantt-rr-geral-wrapper'), allResults.rr.ganttData, totalTimeRR, originalProcesses);

                const totalTimeMLFQ = allResults.mlfq?.gantt?.geral?.reduce((sum, item) => sum + item.duration, 0) || 0;
                if (totalTimeMLFQ > 0 && allResults.mlfq.gantt) {
                    renderGantt(document.getElementById('gantt-mlfq-geral-wrapper'), allResults.mlfq.gantt.geral, totalTimeMLFQ, originalProcesses, 0);
                    renderGantt(document.getElementById('gantt-mlfq-q1-wrapper'), allResults.mlfq.gantt.q1, totalTimeMLFQ, originalProcesses, 1);
                    renderGantt(document.getElementById('gantt-mlfq-q2-wrapper'), allResults.mlfq.gantt.q2, totalTimeMLFQ, originalProcesses, 2);
                    renderGantt(document.getElementById('gantt-mlfq-q3-wrapper'), allResults.mlfq.gantt.q3, totalTimeMLFQ, originalProcesses, 3);
                }
            } catch (error) {
                 console.error("Erro durante a renderização dos gráficos Gantt:", error);
                 alert("Erro ao renderizar os gráficos. Verifique o console.");
            }


             // Preenche a tabela de comparação final
             const comparisonTableBody = document.getElementById('comparison-table-body');
             if (comparisonData.length > 0) {
                 // Encontra os menores valores de TMT e TME
                 const bestTMT = Math.min(...comparisonData.map(d => d.tmt));
                 const bestTME = Math.min(...comparisonData.map(d => d.tme));

                 comparisonData.forEach(data => {
                     const row = document.createElement('tr');
                     row.innerHTML = `
                         <td class="table-cell font-medium">${data.name}</td>
                         <td class="table-cell ${data.tmt === bestTMT ? 'best-metric' : ''}">${data.tmt.toFixed(2)}</td>
                         <td class="table-cell ${data.tme === bestTME ? 'best-metric' : ''}">${data.tme.toFixed(2)}</td>
                     `;
                     comparisonTableBody.appendChild(row);
                 });
             }
        }

    </script>
</body>
</html>

